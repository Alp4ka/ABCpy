# ДЗ#3 по дисциплине "Архитектура вычислительных систем". Python, Динамическая типизация.Объектно-ориентированный подход. 
## Выполнил Горковец Роман Романович, БПИ204 
 13 Вариант. 9 Алгоритм. (Растения -> StraightMerge)
> **Важно!** В качестве доп. функционала реализована правдоподобная генерация названий растений. Составление словаря организованно отдельной подпрограммой, написанной автором.
***
### Структура проекта

Наименование | Количество
----- | -----
.py | 12

Наименование | Вес
----- | -----
Файлы исходного кода | 16 810 bytes

 * **logger/** _Здесь хранится логгер_
    * __init__.py
    * Logger.py _Удобный, форматированный вывод на экран_
 * **container/** _Директория с модулями контейнеров_
   * __init__.py
   * Container.py
 * **utils/** _Директория с модулем вспомогательных функций_
   * __init__.py
   * Flags.py _Логика обработки флагов_
   * functions.py _Рассчет количества гласных/подсчет отношения к числу букв в слове_
 * **algorithms/** _Директория с модулем сортировок_
    * MergeSort.py
    * __init__.py
 * **tests/** _Директория с тестовыми данными_
    * input1.txt
    * output1.txt
    * input2.txt
    * output2.txt
    * input3.txt
    * output3.txt
    * input4.txt
    * output4.txt
    * input5.txt
    * output5.txt
 * **models/** _Директория с модулями моделей_
    * Plants.py _Классы растений, перечисления_
 * main.py - _Мэйн_
***
### Запуск:
Стандартный:
```sh
./main.py -i ./tests/input1.txt -o ./tests/output1.txt
```
> **Важно:** пример ниже указандля того случая, когда вы находитесь в папке с исполняемым файлом!
Предполагается, что при стандартном запуске входный файл доступен и заполнен данными.


Рандомная генерация (-r):
```sh
./main.py -r 34 -i input_file.txt -o output_file.txt
```
> **Важно:** в input_file.txt запишется результат рандомной генерации 34 элементов.

---
### Показатели проззодительности(**StraightMerge**):
Количество элементов контейнера | Среденее время выполнения(n=10) | Функциональный подход(n=10) C | ООП подход(n=10) C++
----- | --- | ---- | ---- |
10 | 1 | 0 ms | 0ms
100 | 16 ms | 10 ms | 6 ms
1000 | 284 ms | 210 ms | 103 ms
10000 | 3900 ms | 2735 ms | 1702 ms

### Вывод
Код на Python выполняется медленнее в первую очередь из-за устройства языка. Т.к. Python - это интерпретируемый, а не компилируемый ЯП, то каждый раз приходится заново интерпретировать операторы и т.д. Также, ввиду динамической типизации языка приходится тратить время на проверку типов.
